[[_remote_branches]]
=== Vzdálené větve

(((větve, vzdálené)))(((reference, vzdálené)))
Vzdálené reference jsou odkazy (ukazatelé) ve vašich vzdálených repozitářích a zahrnují větve, značky (tag) a další.
Seznam vzdálených referencí pro vzdálené větve a také další informace můžete získat explicitním příkazem `git ls-remote (vzdálený repozitář)` nebo `git remote show (vzdálený repozitář)`.
Nicméně, běžnější bývá využití sledujících větví.

Sledující větve (remote-tracking branches{empty}footnote:[Pozn. překl.: „Remote-tracking branches“ lze obtížně přeložit přesným a stručným pojmem. Význam vyplývá z dalšího popisu. Doslova by to bylo „větve sledující z povzdálí“ s významem „lokální větve, které sledují stav vzdálených větví“.]) jsou reference na stav vzdálených větví.
Jsou to lokální reference, které nemůžete posunovat. Posunují se automaticky v době, kdy probíhá komunikace po síti.
Sledující větve fungují jako záložky, které vám připomínají, kde byly větve ve vzdálených repozitářích v době, kdy jste se k nim naposledy připojili.

Mají podobu `(vzdálený repozitář)/(větev)`.
Pokud například chcete zjistit, jak vypadala větev `master` ve vašem vzdáleném repozitáři `origin`, když jste s ní naposledy komunikovali, budete hledat větev `origin/master`.
Pokud pracujete s kolegou na nějakém problému a on odešle (push) větev s názvem `iss53`, může se stát, že i vy máte jednu z lokálních větví pojmenovanou jako `iss53`. Větev na serveru však ukazuje na bod zápisu označený jako `origin/iss53`.

Mohlo by to být trochu matoucí, takže si uveďme příklad.
Řekněme, že máte v síti gitový server označený `git.ourcompany.com`.
Pokud z něj naklonujete, příkaz Gitu `clone` ho automaticky pojmenuje `origin`, stáhne z něj všechna data, vytvoří ukazatel, který bude označovat jeho větev `master` a lokálně ji pojmenuje `origin/master`.
Git rovněž vytvoří vaši vlastní lokální větev `master`, která bude začínat ve stejném místě jako větev `master` serveru `origin`. Takže máte výchozí bod pro svou práci.

[NOTE]
.Název „origin“ není nijak speciální
====
Stejně jako jméno větve „master“ nemá pro Git žádný speciální význam, ani název „origin“ není nijak zvláštní.
Zatímco „master“ je výchozí jméno pro počáteční větev po provedení `git init` -- což je jediný důvod, proč se tak často používá --{empty}, „origin“ je výchozí jméno pro vzdálený repozitář po provedení příkazu `git clone`.
Pokud místo toho spustíte `git clone -o booyah`, dostanete jako výchozí vzdálenou větev `booyah/master`.(((origin)))
====

.Repozitář na serveru a lokální repozitář po klonování
image::images/remote-branches-1.png[Repozitář na serveru a lokální repozitář po klonování.]

Pokud budete pracovat ve vaší lokální větvi `master` a mezi tím někdo jiný něco odešle na `git.ourcompany.com` -- čímž aktualizuje větev `master` tohoto serveru --{empty}, budou se vaše historie vyvíjet odlišně.
A dokud nenavážete se serverem `origin` kontakt, nebude se váš ukazatel `origin/master` posunovat.

.Lokální a vzdálená historie práce se může rozcházet
image::images/remote-branches-2.png[Lokální a vzdálená historie práce se může rozcházet.]

K synchronizaci své práce použijte příkaz `git fetch origin`.
Tento příkaz zjistí, který server je `origin` (v tomto případě je to `git.ourcompany.com`), vyzvedne z něj všechna data, která ještě nemáte, a aktualizuje vaši lokální databázi. Při tom přemístí ukazatel `origin/master` na novou, aktuálnější pozici.

.`git fetch` aktualizuje reference do vzdáleného repozitáře
image::images/remote-branches-3.png[`git fetch` aktualizuje reference do vzdáleného repozitáře.]

Abychom si mohli ukázat, jak se pracuje s několika vzdálenými servery a jak vypadají vzdálené větve takových vzdálených projektů, předpokládejme, že máte ještě další interní server Git, který při vývoji používá pouze jeden z vašich sprint teamů{empty}footnote:[Pozn. překl.: Pojem „sprint tým“ pochází z agilní vývojové metodologie https://cs.wikipedia.org/wiki/Scrum[Scrum].].
Tento server se nachází na `git.team1.ourcompany.com`.
Můžete ho přidat jako novou vzdálenou referenci k projektu, na němž právě pracujete, spuštěním příkazu `git remote add` -- jak jsme si ukázali v kapitole <<_git_basics_chapter>>.
Pojmenujte tento vzdálený server jako `teamone`, což bude zkrácený název pro celou URL adresu.

.Přidání dalšího serveru v roli vzdáleného repozitáře
image::images/remote-branches-4.png[Přidání dalšího serveru v roli vzdáleného repozitáře.]

Nyní můžete spustit příkaz `git fetch teamone`, který ze vzdáleného serveru `teamone` vyzvedne vše, co ještě nemáte.
Protože je tento server podmnožinou dat, která jsou právě na serveru `origin`, Git nevyzvedne žádná data, ale nastaví sledovací větev nazvanou `teamone/master` tak, aby ukazovala na stejný bod zápisu, na který ukazuje větev `master` na serveru `teamone`.

.Sledovací větev pro `teamone/master`
image::images/remote-branches-5.png[RSledovací větev pro `teamone/master`.]

[[_pushing_branches]]
==== Odesílání

(((odesílání)))
Chcete-li svou větev sdílet s okolním světem, musíte ji odeslat (push) na vzdálený server, k němuž máte oprávnění pro zápis.
Vaše lokální větve nejsou automaticky synchronizovány se vzdálenými servery, na které zapisujete –- ty, které chcete sdílet, musíte explicitně odeslat.
Tímto způsobem si můžete zachovat soukromé větve pro práci, kterou nehodláte sdílet, a odesílat pouze tématické větve, na nichž chcete spolupracovat.

Máte-li větev s názvem `serverfix`, na níž chcete spolupracovat s ostatními, můžete ji odeslat stejným způsobem, jakým jste odesílali svou první větev.
Spusťte `git push (remote) (branch)`:(((git příkazy, push)))

[source,console]
----
$ git push origin serverfix
Counting objects: 24, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
Total 24 (delta 2), reused 0 (delta 0)
To https://github.com/schacon/simplegit
 * [new branch]      serverfix -> serverfix
----

Toto je zkrácená verze příkazu.
Git automaticky rozšíří název větve `serverfix` na `refs/heads/serverfix:refs/heads/serverfix`, což znamená: „Vezmi mou lokální větev `serverfix` a odešli ji na vzdálený server, kde aktualizuje tamní větev `serverfix`.“ Části `refs/heads/` se budeme podrobněji věnovat v kapitole <<_git_internals>>, ale nemusí být pro vás zajímavá.
Můžete zadat také příkaz `git push origin serverfix:serverfix`, který provede totéž. Vyjadřuje: „Vezmi mou větev `serverfix` a udělej z ní `serverfix` na vzdáleném serveru.“ Tento formát můžete použít k odeslání lokální větve do vzdálené větve, která se jmenuje jinak.
Pokud jste nechtěli, aby se větev na vzdáleném serveru jmenovala `serverfix`, mohli jste místo toho spustit `git push origin serverfix:awesomebranch`. Pak by lokální větev `serverfix` byla odeslána do větve `awesomebranch` ve vzdáleném projektu.

[NOTE]
.Nepište pokaždé své heslo
====
Pokud práci odesíláte přes HTTPS URL, vyptává se vás gitový server na jméno a heslo kvůli autentizaci.
Aby byl schopen zjistit, zda máte právo k odesílání (push), vypíše výzvu k zadání této informace na terminálu.

Pokud se vám to nechce zadávat při každém odesílání, můžete si nastavit „credential cache“, čili „mezipaměť pro pověřovací informace“.
Nejjednodušší je podržet tyto informace pár minut v paměti, čehož snadno dosáhnete spuštěním `git config --global credential.helper cache`.

Více informací o různých volbách pro uchovávání pověřovacích dat naleznete v podkapitole <<_credential_caching>>.
====

Až bude příště některý z vašich spolupracovníků vyzvedávat data ze serveru, obdrží referenci na místo, kde se nachází serverová verze větve `serverfix` pod jménem vzdálené větve `origin/serverfix`:

[source,console]
----
$ git fetch origin
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://github.com/schacon/simplegit
 * [new branch]      serverfix    -> origin/serverfix
----

Tady je důležité upozornit, že pokud provedete vyzvednutí (fetch), které získá i nové sledovací větve, nezískáváte automaticky i jejich lokální, editovatelné kopie.
Jinými slovy, v tomto případě nevznikne nová větev `serverfix`. Získáte jen ukazatel `origin/serverfix`, který nemůžete měnit.

Chcete-li začlenit tato data do své aktuální pracovní větve, můžete provést příkaz `git merge origin/serverfix`.
Pokud chcete mít svou vlastní větev `serverfix`, na které byste mohli pracovat, můžete ji odvodit ze sledovací větve:

[source,console]
----
$ git checkout -b serverfix origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

Tímto způsobem získáte lokální větev, na níž můžete pracovat a která začíná na pozici `origin/serverfix`.

[[_tracking_branches]]
==== Tracking Branches

(((branches, tracking)))(((branches, upstream)))
Checking out a local branch from a remote-tracking branch automatically creates what is called a ``tracking branch'' (or sometimes an ``upstream branch'').
Sledující větve jsou lokální větve s přímým vztahem ke vzdálené větvi.
If you're on a tracking branch and type `git pull`, Git automatically knows which server to fetch from and branch to merge into.

Pokud klonujete repozitář, většinou se vytvoří větev `master`, která bude sledovat větev `origin/master`.
However, you can set up other tracking branches if you wish – ones that track branches on other remotes, or don't track the `master` branch.
Jednoduchým případem je příklad, který jste právě viděli: spuštění příkazu `git checkout -b [větev] [vzdálený server]/[větev]`.
This is a common enough operation that git provides the `--track` shorthand:

[source,console]
----
$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

In fact, this is so common that there's even a shortcut for that shortcut. If the branch name you're trying to checkout (a) doesn't exist and (b) exactly matches a name on only one remote, Git will create a tracking branch for you:

[source,console]
----
$ git checkout serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

Chcete-li nastavit lokální větev s jiným názvem, než má vzdálená větev, můžete jednoduše použít první variantu s odlišným názvem lokální větve:

[source,console]
----
$ git checkout -b sf origin/serverfix
Branch sf set up to track remote branch serverfix from origin.
Switched to a new branch 'sf'
----

Now, your local branch `sf` will automatically pull from `origin/serverfix`.

If you already have a local branch and want to set it to a remote branch you just pulled down, or want to change the upstream branch you're tracking, you can use the `-u` or `--set-upstream-to` option to `git branch` to explicitly set it at any time.

[source,console]
----
$ git branch -u origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
----

[NOTE]
.Upstream shorthand
====
When you have a tracking branch set up, you can reference it with the `@{upstream}` or `@{u}` shorthand.
So if you're on the `master` branch and it's tracking `origin/master`, you can say something like `git merge @{u}` instead of `git merge origin/master` if you wish.(((+++@{u}+++)))(((+++@{upstream}+++)))
====

If you want to see what tracking branches you have set up, you can use the `-vv` option to `git branch`.
This will list out your local branches with more information including what each branch is tracking and if your local branch is ahead, behind or both.

[source,console]
----
$ git branch -vv
  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets
  master    1ae2a45 [origin/master] deploying index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
  testing   5ea463a trying something new
----

So here we can see that our `iss53` branch is tracking `origin/iss53` and is ``ahead'' by two, meaning that we have two commits locally that are not pushed to the server.
We can also see that our `master` branch is tracking `origin/master` and is up to date.
Next we can see that our `serverfix` branch is tracking the `server-fix-good` branch on our `teamone` server and is ahead by three and behind by one, meaning that there is one commit on the server we haven't merged in yet and three commits locally that we haven't pushed.
Finally we can see that our `testing` branch is not tracking any remote branch.

It's important to note that these numbers are only since the last time you fetched from each server.
This command does not reach out to the servers, it's telling you about what it has cached from these servers locally.
If you want totally up to date ahead and behind numbers, you'll need to fetch from all your remotes right before running this.
You could do that like this: `$ git fetch --all; git branch -vv`

==== Pulling

(((pulling)))
While the `git fetch` command will fetch down all the changes on the server that you don't have yet, it will not modify your working directory at all.
It will simply get the data for you and let you merge it yourself.
However, there is a command called `git pull` which is essentially a `git fetch` immediately followed by a `git merge` in most cases.
If you have a tracking branch set up as demonstrated in the last section, either by explicitly setting it or by having it created for you by the `clone` or `checkout` commands, `git pull` will look up what server and branch your current branch is tracking, fetch from that server and then try to merge in that remote branch.

Generally it's better to simply use the `fetch` and `merge` commands explicitly as the magic of `git pull` can often be confusing.

[[_delete_branches]]
==== Deleting Remote Branches

(((branches, deleting remote)))
Suppose you're done with a remote branch – say you and your collaborators are finished with a feature and have merged it into your remote's `master` branch (or whatever branch your stable codeline is in).
You can delete a remote branch using the `--delete` option to `git push`.
Chcete-li ze serveru odstranit větev `serverfix`, můžete to provést takto:

[source,console]
----
$ git push origin --delete serverfix
To https://github.com/schacon/simplegit
 - [deleted]         serverfix
----

Basically all this does is remove the pointer from the server.
The Git server will generally keep the data there for a while until a garbage collection runs, so if it was accidentally deleted, it's often easy to recover.
