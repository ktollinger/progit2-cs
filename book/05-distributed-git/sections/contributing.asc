[[_contributing_project]]
=== Přispívání do projektu

(((přispívání)))
Hlavní potíž při popisu způsobu přispívání do projektu spočívá v tom, že existuje obrovské množství variací, jak se to dá udělat.
Git je velmi pružný, lidé mohou spolupracovat různými způsoby (a taky to tak dělají), takže není snadné popsat, jakým způsobem byste měli přispívat. Každý projekt je trochu jiný.
Mezi proměnné v tomto procesu patří počet aktivních přispěvatelů, zvolený pracovní postup, vaše oprávnění pro odesílání revizí a případně i metoda externího přispívání.

První proměnnou je počet aktivních přispěvatelů. Kolik uživatelů aktivně přispívá svým kódem do projektu a jak často?
V mnoha případech budete mít dva nebo tři vývojáře přispívající několika málo revizemi denně. U spících projektů to bude i méně.
U větších společností nebo u větších projektů může počet vývojářů dosahovat tisíců -- při stovkách nebo tisících zápisů revizí (commit) denně.
Počet přispěvatelů je důležitý, protože s rostoucím počtem vývojářů narůstají i potíže se zajištěním toho, aby byl váš kód aplikován čistě, nebo aby ho bylo možné snadno začlenit (merge).
Vámi odeslané změny se mohou ukázat jako zastaralé nebo vážně narušené pracemi, které byly do projektu začleněny během vaší práce, nebo v době, kdy vaše změny čekaly na schválení či aplikaci.
Jak lze dosáhnout neustálé aktuálnosti vašeho kódu a platnosti vašich revizí?

Další proměnnou je pracovní postup, který se u projektu využívá.
Probíhá vývoj centralizovaně s tím, že každý vývojář má stejné oprávnění pro zápis do hlavní linie kódu?
Má projekt svého správce nebo integračního manažera, který kontroluje všechny záplaty?
Jsou všechny záplaty odborně posuzovány a schvalovány?
Jste součástí tohoto procesu?
Jsou součástí systému poručíci a musíte všechnu svou práci odesílat nejprve jim?

Další otázkou je vaše oprávnění k zapisování revizí.
Pracovní postup při přispívání do projektu se velmi liší podle toho, zda máte, či nemáte oprávnění k zápisu do projektu.
Pokud oprávnění k zápisu nemáte, jaké metodě se dává přednost při přijímání příspěvků?
Je nějaká strategie vůbec určena?
Kolik práce představuje jeden váš příspěvek?
A jak často přispíváte?

Všechny tyto otázky mohou mít vliv na efektivní přispívání do projektu a určují, jaký pracovní postup je vůbec možný a který bude upřednostněn.
Každou z těchto otázek si probereme na sérii praktických případů, postupně od jednodušších po složitější. Z uvedených příkladů byste si měli být schopni odvodit vlastní pracovní postup, který budete v praxi využívat.

[[_commit_guidelines]]
==== Pravidla pro zápis revizí

Než se podíváme na konkrétní případy, uveďme rychlou poznámku o zprávách k revizím.
Pokud stanovíte dobrá pravidla pro vytváření revizí (commit) a pokud se jich budete držet, bude práce s Gitem a spolupráce s ostatními mnohem jednodušší.
Samotný projekt Git obsahuje dokument, v němž je navržena celá řada dobrých tipů pro vytváření revizí, z kterých se vytvářejí záplaty. Najdete ho ve zdrojovém kódu systému Git, v souboru `Documentation/SubmittingPatches`.

(((git příkazy, diff, check)))
Především nechcete odesílat chybně použité prázdné znaky (whitespace).
Git nabízí snadný způsob, jak tyto chyby zkontrolovat. Před zapsáním revize spusťte `git diff --check`, který zkontroluje prázdné znaky a zobrazí vám je.

.Výstup příkazu `git diff --check`.
image::images/git-diff-check.png[Výstup příkazu `git diff --check`.]

Spustíte-li tento příkaz před zapsáním revize, můžete zjistit, zda se budou zapisovat i problematické prázdné znaky, které by mohly ostatní vývojáře obtěžovat.

Dále se snažte provádět každý zápis (commit) jako logicky oddělený soubor změn.
Pokud je to možné, snažte se, aby byly vaše změny stravitelné. Není právě ideální pracovat celý víkend na pěti různých problémech a v pondělí je všechny najednou odeslat formou jedné velké revize.
Když už během víkendu nebudete zapisovat revize, využijte v pondělí oblasti připravených změn pro rozdělení práce alespoň do stejného počtu revizí, kolik je řešených problémů, a přidejte k nim vysvětlující zprávy.
Pokud některé změny upravují stejný soubor, zkuste použít příkaz `git add --patch` a připravit soubory k zapsání po částech (podrobnosti jsou popsány v kapitole <<_interactive_staging>>).
Snímek projektu na vrcholu větve bude stejný, ať zapíšete jednu revizi, nebo pět (za předpokladu, že vložíte všechny změny). Snažte se proto usnadnit práci svým kolegům, kteří možná někdy budou vaše změny revidovat.
Takový přístup současně usnadňuje stahování změn (pull) nebo vracení jedné sady změn do původního stavu -- bude-li to později třeba.
Podkapitola <<_rewriting_history>> popisuje několik užitečných triků, jak v systému Git přepsat historii a jak interaktivně připravovat soubory k zapsání. Než svou práci odešlete ostatním, použijte tyto nástroje k udržení čisté a srozumitelné historie.

Poslední věcí, na kterou byste měli myslet, jsou zprávy k revizím.
Pokud si zvyknete připisovat k revizím kvalitní zprávy, bude pro vás práce s Gitem a spolupráce s ostatními mnohem jednodušší.
Základním pravidlem je, že by vaše zprávy měly začínat jedním řádkem, který nemá víc než asi 50 znaků a který popisuje sadu provedených změn. Za ním následuje prázdný řádek a potom podrobnější vysvětlení.
Projekt Git vyžaduje, aby podrobnější popis revize zahrnoval i vaši motivaci ke změnám a aby uvedl srovnání nové implementace s původním chováním. Tuto zásadu je dobré dodržovat.
Doporučuje se také, aby se pro zápis zpráv používal rozkazovací způsob.
Jinými slovy, formulujte je jako příkazy.
Místo „Přidal jsem testy pro“ nebo „Přidány testy pro“ použijte „Přidej testy pro“.
Zde je originální (přeložená) šablona, kterou napsal Tim Pope:

[source,text]
----
Krátké shrnutí změn (do 50 znaků)

Podrobnější vysvětlující text, pokud je třeba.  Zalamujte řádky
přibližně na 72 znaků.  Někdy se první řádek používá jako předmět
emailu a zbytek textu jako tělo dopisu.  Prázdný řádek, který
odděluje shrnutí od těla je nezbytně nutný (pokud tělo nevynecháte
úplně); nástroje jako rebase mohou být zmatené, pokud tyto části
neoddělíte.

Další odstavce se oddělují prázdným řádkem.

  - Můžete používat i odrážky.

  - Pro odrážku se typicky používá pomlčka nebo hvězdička,
    před kterou se uvádí jedna mezera. Mezi odrážky se vkládají
    prázdné řádky, ale tady se zvyklosti mohou lišit.
----

Pokud budou všechny vaše zprávy k revizím vypadat takto, usnadníte tím práci sobě i svým spolupracovníkům.
Projekt Git obsahuje kvalitně naformátované zprávy k revizím. Zkuste spustit `git log --no-merges`, abyste se podívali, jak vypadá pěkně naformátovaná historie revizí projektu.

V následujících příkladech -- a ve většině ukázek v knize -- se takto pěkně naformátované zprávy nepoužívají kvůli stručnosti. Místo toho budeme používat volbu `-m` za příkazem `git commit`.
Dělejte to, jak říkám, a ne jak to dělám.

[[_private_team]]
==== Malý soukromý tým

(((přispívání, malý soukromý tým)))
Nejjednodušší situaci, s kterou se asi setkáte, je soukromý projekt s jedním nebo pár dalšími vývojáři.
„Soukromý“ v této souvislosti znamená s uzavřeným zdrojovým kódem -- okolní svět k němu nemá přístup.
Vy a vaši ostatní vývojáři máte všichni oprávnění odesílat změny do repozitáře (push).

V takovém prostředí můžete uplatnit podobný pracovní postup, na jaký jste možná zvyklí ze systému Subversion nebo z jiného centralizovaného systému.
Přesto získáte výhody v takových ohledech, jako je zapisování revizí offline a podstatně snazší větvení a slučování. Pracovní postup však bude velmi podobný. Hlavním rozdílem je to, že slučování probíhá na straně klienta, a ne během zapisování revize na straně serveru.
Podívejme se, jak to může vypadat, když dva vývojáři začnou spolupracovat na projektu se sdíleným repozitářem.
První vývojář, John, naklonuje repozitář, provede změny a zapíše lokální revizi.
(V následujících příkladech byly zprávy protokolů nahrazeny třemi tečkami, abych je trochu zkrátil.)

[source,console]
----
# John's Machine
$ git clone john@githost:simplegit.git
Cloning into 'simplegit'...
...
$ cd simplegit/
$ vim lib/simplegit.rb
$ git commit -am 'removed invalid default value'
[master 738ee87] removed invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)
----

Druhá vývojářka, Jessica, učiní totéž -- naklonuje repozitář a zapíše provedenou změnu:

[source,console]
----
# Jessica's Machine
$ git clone jessica@githost:simplegit.git
Cloning into 'simplegit'...
...
$ cd simplegit/
$ vim TODO
$ git commit -am 'add reset task'
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)
----

Jessica teď odešle (push) svou práci na server:

[source,console]
----
# Jessica's Machine
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -> master
----

Také John se pokusí odeslat své změny na server:

[source,console]
----
# John's Machine
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -> master (non-fast forward)
error: failed to push some refs to 'john@githost:simplegit.git'
----

John nemá povoleno odeslat změny, protože mezitím odeslala své změny Jessica.
Pochopit to je obzvlášť důležité v případě, kdy jste zvyklí na Subversion. Můžete si totiž všimnout, že oba vývojáři neupravovali stejný soubor.
Pokud byly upraveny různé soubory, provádí Subversion takové sloučení na serveru automaticky. Ale v Gitu musíte provést sloučení revizí (merge) lokálně.
John musí vyzvednout (fetch) změny, které provedla Jessica, a začlenit je (merge) do své práce. Teprve potom mu bude umožněno je odeslat (push):

[source,console]
----
$ git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -> origin/master
----

V tomto okamžiku vypadá Johnův lokální repozitář nějak takto:

.Johnova odchylující se historie.
image::images/small-team-1.png[Johnova odchylující se historie.]

John má k dispozici odkaz na změny, které odeslala Jessica, ale než bude moci sám odeslat svá data, bude muset začlenit její práci:

[source,console]
----
$ git merge origin/master
Merge made by recursive.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
----

Sloučení probíhá hladce -- Johnova historie revizí teď vypadá takto:

.Johnův repozitář po začlenění `origin/master`.
image::images/small-team-2.png[Johnův repozitář po začlenění `origin/master`.]

Teď může John svůj kód otestovat, aby se ujistil, že stále pracuje správně, a pak může odeslat svou novou sloučenou práci na server:

[source,console]
----
$ git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -> master
----

Johnova historie revizí nakonec vypadá takto:

.Johnova historie po odeslání revize na server `origin`.
image::images/small-team-3.png[Johnova historie po odeslání revize na server `origin`.]

Jessica mezitím pracovala na tématické větvi.
Vytvořila tématickou větev s názvem `issue54` a zapsala do ní tři revize.
Zatím ještě nevyzvedla Johnovy změny, takže její historie revizí vypadá nějak takto:

.Jessičina tématická větev.
image::images/small-team-4.png[Jessičina tématická větev.]

Jessica chce synchronizovat svou práci s Johnem, a proto vyzvedne jeho data:

[source,console]
----
# Jessica's Machine
$ git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -> origin/master
----

Tím stáhne práci, kterou mezitím odeslal John.
Historie revizí Jessicy teď vypadá takto:

.Historie Jessicy po vyzvednutí Johnových změn.
image::images/small-team-5.png[Historie Jessicy po vyzvednutí Johnových změn.]

Jessica považuje svou tématickou větev za dokončenou, ale chce zjistit, co by měla do své práce začlenit, aby ji mohla odeslat.
Spustí proto příkaz `git log`:

[source,console]
----
$ git log --no-merges issue54..origin/master
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 16:01:27 2009 -0700

   removed invalid default value
----

Zápis `issue54..origin/master` předtavuje filtr příkazu, kterým se Gitu říká, aby zobrazil seznam jen těch objektů revize, které se nacházejí v druhé z větví (zde `origin/master`), ale které se nenacházejí v první větvi (zde `issue54`).
Podrobně se budeme touto syntaxí zabývat v části <<_commit_ranges>>.

Z výstupu vidíme, že existuje jediná revize, kterou zapsal John a kterou Jessica nesloučila se svou prací.
Pokud začlení `origin/master`, bude to jediná revize, která změní její lokální práci.

Teď může Jessica začlenit (merge) svou tématickou větev do své větve `master`, začlenit Johnovu práci (`origin/master`) rovněž do své větve `master` a potom vše může odeslat (push) znovu na server.
Nejdříve se přepne zpět na svou větev `master`, aby do ní mohla vše integrovat:

[source,console]
----
$ git checkout master
Switched to branch 'master'
Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
----

Buď může nejdříve začlenit `origin/master` nebo `issue54`. Obě revize jsou následníky té aktuální, takže na pořadí nezáleží.
Konečný snímek bude stejný, ať zvolí jakékoli pořadí. Trochu se bude lišit jen historie revizí.
Jessica se rozhodne začlenit nejdříve `issue54`:

[source,console]
----
$ git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)
----

Nevyskytly se žádné problémy. Jak vidíte, šlo o jednoduchý posun „rychle vpřed“.
Nyní Jessica začlení Johnovu práci (`origin/master`):

[source,console]
----
$ git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)
----

Začlenění proběhne čistě a Jessičina historie bude vypadat následovně:

.Jessičina historie po začlenění Johnových změn.
image::images/small-team-6.png[Jessičina historie po začlenění Johnových změn.]

Větev `origin/master` je dosažitelná z Jessičiny větve `master`, takže by měla být schopná práci úspěšně odeslat (za předpokladu, že John mezitím neodeslal další revizi):

[source,console]
----
$ git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -> master
----

Každý z nich provedl několik zápisů (commit) a úspěšně začlenil (merge) práci toho druhého.

.Jessičina historie po odeslání všech změn zpět na server.
image::images/small-team-7.png[Jessičina historie po odeslání všech změn zpět na server.]

Toto je jeden z nejjednodušších pracovních postupů.
Po určitou dobu pracujete, obvykle na nějaké tématické větvi, a když je připravena k integraci, začleníte ji do své větve `master`.
Chcete-li tuto práci sdílet, začleníte ji (merge) do své větve `master`. Poté vyzvednete změny (fetch) a pokud se větev `origin/master` změnila, začleníte ji (merge). Nakonec odešlete (push) všechna data do větve `master` na serveru.
Obvyklá posloupnost vypadá takto:

.Obecná posloupnost událostí pro jednoduchý pracovní postup s více vývojáři.
image::images/small-team-flow.png[Obecná posloupnost událostí pro jednoduchý pracovní postup s více vývojáři.]

==== Soukromý řízený tým

(((přispívání, soukromý řízený tým)))
V následujícím scénáři se podíváme na role přispěvatelů ve větší soukromé skupině.
Naučíte se, jak pracovat v prostředí, v němž na jednotlivých úkolech spolupracují malé skupiny a tyto týmové příspěvky jsou poté integrovány jinou skupinou.

Řekněme, že John a Jessica spolupracují na jednom úkolu, zatímco Jessica a Josie pracují na jiném.
Společnost v tomto případě používá typ pracovního postupu s integračním manažerem, kdy práci jednotlivých skupin integrují pouze někteří inženýři a větev `master` hlavního repozitáře mohou aktualizovat pouze oni.
V tomto scénáři se veškerá práce provádí ve větvích jednotlivých týmů a později je spojována integrátory.

Sledujme pracovní postup Jessicy pracující na dvou úkolech a spolupracující v tomto prostředí paralelně s dvěma různými vývojáři.
Protože už má naklonovaný repozitář, rozhodne se pracovat nejprve na úkolu `featureA`.
Vytvoří si pro něj novou větev a udělá v ní kus práce:

[source,console]
----
# Jessica's Machine
$ git checkout -b featureA
Switched to a new branch 'featureA'
$ vim lib/simplegit.rb
$ git commit -am 'add limit to log function'
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)
----

V tomto okamžiku potřebuje sdílet svou práci s Johnem, a tak odešle revize své větve `featureA` na server.
Jessica nemá oprávnění pro odesílání dat (push) do větve `master` (ten mají pouze integrátoři), takže aby mohla s Johnem spolupracovat, musí své revize odeslat do jiné větve:

[source,console]
----
$ git push -u origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -> featureA
----

Jessica e-mailem Johnovi sdělí, že odeslala svou práci do větve pojmenované `featureA` a že se na ni může podívat.
Zatímco čeká na zpětnou vazbu od Johna, rozhodne se, že začne pracovat spolu s Josie na úkolu `featureB`.
Začne tím, že založí novou větev, která bude založena na větvi `master` ze serveru:

[source,console]
----
# Jessica's Machine
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch 'featureB'
----

Jessica nyní vytvoří několik revizí ve větvi `featureB`:

[source,console]
----
$ vim lib/simplegit.rb
$ git commit -am 'made the ls-tree function recursive'
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am 'add ls-files'
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)
----

Jessičin repozitář vypadá nějak takto:

.Jessičina výchozí historie revizí.
image::images/managed-team-1.png[Jessičina výchozí historie revizí.]

Je připravena odeslat svou práci, ale dostane e-mail od Josie, že již na server odeslala větev `featureBee`, v níž už je část práce hotová.
Než bude Jessica moci odeslat svou práci na server, bude do ní nejprve muset začlenit práci Josie.
Změny, které Josie provedla, vyzvedne příkazem `git fetch`:

[source,console]
----
$ git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -> origin/featureBee
----

Nyní může Jessica začlenit tyto změny do své práce příkazem `git merge`:

[source,console]
----
$ git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)
----

Tady nastává drobný problém. Musí odeslat sloučenou práce ze své větve `featureB` do větve `featureBee` na serveru.
Může tak učinit příkazem `git push` s určením lokální větve, za níž bude následovat dvojtečka (:) a za ní vzdálená větev:

[source,console]
----
$ git push -u origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -> featureBee
----

Říká se tomu _refspec_.
Podrobnější diskusi o specifikaci gitových referencí a o různých možnostech práce s nimi najdete v kapitole <<_refspec>>.
Všimněte si též příznaku `-u`. Jde o zkratku pro volbu `--set-upstream`, která se používá k nastavení větví pro pozdější zjednodušené odesílání (push) a stahování (pull).

John poté pošle Jessice e-mail, aby jí sdělil, že odeslal několik změn do větve `featureA`, a poprosí ji, aby je ověřila.
Jessica je stáhne spuštěním příkazu `git fetch`:

[source,console]
----
$ git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -> origin/featureA
----

Poté si může příkazem `git log` prohlédnout, co všechno bylo změněno:

[source,console]
----
$ git log featureA..origin/featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25
----

Nakonec začlení Johnovu práci do své vlastní větve `featureA`:

[source,console]
----
$ git checkout featureA
Switched to branch 'featureA'
$ git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)
----

Jessica by ráda něco vylepšila, a proto vytvoří novou revizi a odešle ji zpět na server:

[source,console]
----
$ git commit -am 'small tweak'
[featureA 774b3ed] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
$ git push
...
To jessica@githost:simplegit.git
   3300904..774b3ed  featureA -> featureA
----

Historie revizí Jessicy bude nyní vypadat takto:

.Jessičina historie po zapsání revizí do větve s úkolem.
image::images/managed-team-2.png[Jessičina historie po zapsání revizí do větve s úkolem.]

Jessica, Josie a John pošlou zprávu integrátorům, že větve `featureA` a `featureBee` jsou na serveru připraveny k integraci do hlavní linie.
Poté, co integrátoři uvedené větve začlení do hlavní linie, bude možné vyzvednout (fetch) nový bod sloučení (merge commit) a historie revizí bude vypadat takto:

.Historie Jessicy po začlenění obou jejích tématických větví.
image::images/managed-team-3.png[Historie Jessicy po začlenění obou jejích tématických větví.]

Mnoho skupin přechází na Git právě kvůli této možnosti paralelní spolupráce několika týmů a následného slučování různých linií práce.
Možnost spolupráce menších podskupin týmu prostřednictvím vzdálených větví -- aniž by si práce vyžádala účast celého týmu nebo aby bránila ostatním v jiné práci -- patří k obrovským výhodám Gitu.
Posloupnost událostí ve zde popsaném pracovním postupu vypadá takto:

.Základní posloupnost událostí pracovního postupu řízeného týmu.
image::images/managed-team-flow.png[Základní posloupnost událostí pracovního postupu řízeného týmu.]

[[_public_project]]
==== Forked Public Project

(((contributing, public small project)))
Contributing to public projects is a bit different.
Because you don't have the permissions to directly update branches on the project, you have to get the work to the maintainers some other way.
První příklad popisuje, jak se přispívá s využitím rozštěpení na hostitelských serverech Git, které podporují snadné štěpení.
Many hosting sites support this (including GitHub, BitBucket, Google Code, repo.or.cz, and others), and many project maintainers expect this style of contribution.
The next section deals with projects that prefer to accept contributed patches via email.

First, you'll probably want to clone the main repository, create a topic branch for the patch or patch series you're planning to contribute, and do your work there.
Posloupnost příkazů bude tedy následující:

[source,console]
----
$ git clone (url)
$ cd project
$ git checkout -b featureA
# (work)
$ git commit
# (work)
$ git commit
----

[NOTE]
====
You may want to use `rebase -i` to squash your work down to a single commit, or rearrange the work in the commits to make the patch easier for the maintainer to review – see <<_rewriting_history>> for more information about interactive rebasing.
====

When your branch work is finished and you're ready to contribute it back to the maintainers, go to the original project page and click the ``Fork'' button, creating your own writable fork of the project.
Poté bude třeba, abyste tuto novou adresu URL repozitáře přidali jako druhý vzdálený repozitář, v tomto případě pojmenovaný `myfork`:

[source,console]
----
$ git remote add myfork (url)
----

Then you need to push your work up to it.
It's easiest to push the topic branch you're working on up to your repository, rather than merging into your master branch and pushing that up.
The reason is that if the work isn't accepted or is cherry picked, you don't have to rewind your master branch.
If the maintainers merge, rebase, or cherry-pick your work, you'll eventually get it back via pulling from their repository anyhow:

[source,console]
----
$ git push -u myfork featureA
----

(((git commands, request-pull)))
When your work has been pushed up to your fork, you need to notify the maintainer.
This is often called a pull request, and you can either generate it via the website – GitHub has its own Pull Request mechanism that we'll go over in <<_github>> – or you can run the `git request-pull` command and email the output to the project maintainer manually.

The `request-pull` command takes the base branch into which you want your topic branch pulled and the Git repository URL you want them to pull from, and outputs a summary of all the changes you're asking to be pulled in.
For instance, if Jessica wants to send John a pull request, and she's done two commits on the topic branch she just pushed up, she can run this:

[source,console]
----
$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
  John Smith (1):
        added a new function

are available in the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith (2):
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)
----

The output can be sent to the maintainer – it tells them where the work was branched from, summarizes the commits, and tells where to pull this work from.

On a project for which you're not the maintainer, it's generally easier to have a branch like `master` always track `origin/master` and to do your work in topic branches that you can easily discard if they're rejected.
Jednotlivé úkoly izolované v tématických větvích mají také tu výhodu, že snáze přeskládáte svou práci, jestliže se průběžně posouvá konec hlavního repozitáře a vaše revize už nelze aplikovat čistě.
For example, if you want to submit a second topic of work to the project, don't continue working on the topic branch you just pushed up – start over from the main repository's `master` branch:

[source,console]
----
$ git checkout -b featureB origin/master
# (work)
$ git commit
$ git push myfork featureB
# (email maintainer)
$ git fetch origin
----

Now, each of your topics is contained within a silo – similar to a patch queue – that you can rewrite, rebase, and modify without the topics interfering or interdepending on each other, like so:

.Initial commit history with `featureB` work.
image::images/public-small-1.png[Initial commit history with `featureB` work.]

Let's say the project maintainer has pulled in a bunch of other patches and tried your first branch, but it no longer cleanly merges.
V takovém případě můžete zkusit přeskládat tuto větev na vrcholu větve `origin/master`, vyřešit za správce vzniklé konflikty a poté své změny ještě jednou odeslat:

[source,console]
----
$ git checkout featureA
$ git rebase origin/master
$ git push -f myfork featureA
----

This rewrites your history to now look like <<psp_b>>.

[[psp_b]]
.Commit history after `featureA` work.
image::images/public-small-2.png[Commit history after `featureA` work.]

Because you rebased the branch, you have to specify the `-f` to your push command in order to be able to replace the `featureA` branch on the server with a commit that isn't a descendant of it.
Druhou možností je odeslat tuto novou práci do jiné větve na serveru (nazvané např. `featureAv2`).

Let's look at one more possible scenario: the maintainer has looked at work in your second branch and likes the concept but would like you to change an implementation detail.
You'll also take this opportunity to move the work to be based off the project's current `master` branch.
Začnete vytvořením nové větve z aktuální větve `origin/master`, zkomprimujete do ní změny z větve `featureB`, vyřešíte všechny konflikty, provedete změnu v implementaci a to vše odešlete jako novou větev:

(((git commands, merge, squash)))
[source,console]
----
$ git checkout -b featureBv2 origin/master
$ git merge --squash featureB
# (change implementation)
$ git commit
$ git push myfork featureBv2
----

The `--squash` option takes all the work on the merged branch and squashes it into one changeset producing the repository state as if a real merge happened, without actually making a merge commit.
This means your future commit will have one parent only and allows you to introduce all the changes from another branch and then make more changes before recording the new commit.
Also the `--no-commit` option can be useful to delay the merge commit in case of the default merge process.

Now you can send the maintainer a message that you've made the requested changes and they can find those changes in your `featureBv2` branch.

.Commit history after `featureBv2` work.
image::images/public-small-3.png[Commit history after `featureBv2` work.]

[[_project_over_email]]
==== Public Project over Email

(((contributing, public large project)))
Many projects have established procedures for accepting patches – you'll need to check the specific rules for each project, because they will differ.
Since there are several older, larger projects which accept patches via a developer mailing list, we'll go over an example of that now.

The workflow is similar to the previous use case – you create topic branches for each patch series you work on.
Liší se to, jak je budete doručovat do projektu.
Instead of forking the project and pushing to your own writable version, you generate email versions of each commit series and email them to the developer mailing list:

[source,console]
----
$ git checkout -b topicA
# (work)
$ git commit
# (work)
$ git commit
----

(((git commands, format-patch)))
Now you have two commits that you want to send to the mailing list.
You use `git format-patch` to generate the mbox-formatted files that you can email to the list – it turns each commit into an email message with the first line of the commit message as the subject and the rest of the message plus the patch that the commit introduces as the body.
The nice thing about this is that applying a patch from an email generated with `format-patch` preserves all the commit information properly.

[source,console]
----
$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
----

Příkaz `format-patch` vypíše názvy souborů záplaty, kterou vytváří.
Přepínač `-M` řekne systému Git, aby zkontroloval případné přejmenování.
Soubory nakonec vypadají takto:

[source,console]
----
$ cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log #{treeish}")
+    command("git log -n 20 #{treeish}")
   end

   def ls_tree(treeish = 'master')
--
2.1.0
----

You can also edit these patch files to add more information for the email list that you don't want to show up in the commit message.
If you add text between the `---` line and the beginning of the patch (the `diff --git` line), then developers can read it; but applying the patch excludes it.

To email this to a mailing list, you can either paste the file into your email program or send it via a command-line program.
Pasting the text often causes formatting issues, especially with ``smarter'' clients that don't preserve newlines and other whitespace appropriately.
Git naštěstí nabízí nástroj, který vám pomůže odeslat správně formátované patche pomocí protokolu IMAP.
We'll demonstrate how to send a patch via Gmail, which happens to be the email agent we know best; you can read detailed instructions for a number of mail programs at the end of the aforementioned `Documentation/SubmittingPatches` file in the Git source code.

(((git commands, config)))(((email)))
First, you need to set up the imap section in your `~/.gitconfig` file.
You can set each value separately with a series of `git config` commands, or you can add them manually, but in the end your config file should look something like this:

[source,ini]
----
[imap]
  folder = "[Gmail]/Drafts"
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = p4ssw0rd
  port = 993
  sslverify = false
----

If your IMAP server doesn't use SSL, the last two lines probably aren't necessary, and the host value will be `imap://` instead of `imaps://`.
Až toto nastavení dokončíte, můžete použít příkaz `git imap-send`, jímž umístíte sérii záplat (patch) do složky Koncepty (Drafts) zadaného serveru IMAP:

[source,console]
----
$ cat *.patch |git imap-send
Resolving imap.gmail.com... ok
Connecting to [74.125.142.109]:993... ok
Logging in...
sending 2 messages
100% (2/2) done
----

At this point, you should be able to go to your Drafts folder, change the To field to the mailing list you're sending the patch to, possibly CC the maintainer or person responsible for that section, and send it off.

Záplaty můžete odesílat i přes SMTP server.
Stejně jako v předchozím případu můžete nastavit sérií příkazů `git config` každou hodnotu zvlášť, nebo je můžete vložit ručně do sekce sendemail souboru `~/.gitconfig`:

[source,ini]
----
[sendemail]
  smtpencryption = tls
  smtpserver = smtp.gmail.com
  smtpuser = user@gmail.com
  smtpserverport = 587
----

Jakmile je to hotové, můžete záplaty odeslat příkazem `git send-email`:

[source,console]
----
$ git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith <jessica@example.com>]
Emails will be sent from: Jessica Smith <jessica@example.com>
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y
----

Then, Git spits out a bunch of log information looking something like this for each patch you're sending:

[source,text]
----
(mbox) Adding cc: Jessica Smith <jessica@example.com> from
  \line 'From: Jessica Smith <jessica@example.com>'
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith <jessica@example.com>
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: <1243715356-61726-1-git-send-email-jessica@example.com>
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: <y>
References: <y>

Result: OK
----

==== Shrnutí

This section has covered a number of common workflows for dealing with several very different types of Git projects you're likely to encounter, and introduced a couple of new tools to help you manage this process.
Next, you'll see how to work the other side of the coin: maintaining a Git project.
You'll learn how to be a benevolent dictator or integration manager.
